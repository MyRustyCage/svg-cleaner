<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SVG Cleaner Test</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: system-ui, -apple-system, sans-serif;
        padding: 16px;
        font-size: 13px;
        background: #f9f9f9;
      }
      h3 {
        margin-bottom: 12px;
        font-size: 16px;
        color: #333;
      }
      select,
      button {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 13px;
      }
      button {
        background: #5865f2;
        color: white;
        cursor: pointer;
        font-weight: 500;
      }
      button:hover {
        background: #4752c4;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .btn-success {
        background: #3ba55d;
      }
      .btn-success:hover {
        background: #2d7d46;
      }
      label {
        display: block;
        margin: 12px 0 4px;
        font-weight: 600;
        color: #555;
      }
      textarea {
        width: 100%;
        height: 120px;
        padding: 8px;
        font-family: "Courier New", monospace;
        font-size: 11px;
        border: 1px solid #ddd;
        border-radius: 4px;
        resize: vertical;
        background: white;
      }
      #status {
        margin-top: 12px;
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .ok {
        background: #d4f4dd;
        color: #1a7f37;
        border: 1px solid #1a7f37;
      }
      .err {
        background: #fde7e9;
        color: #b42318;
        border: 1px solid #b42318;
      }
      .info {
        background: #e7f3ff;
        color: #0969da;
        border: 1px solid #0969da;
      }
      .section {
        background: white;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 12px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>
  <body>
    <h3>🧪 SVG Cleaner Test</h3>

    <div class="section">
      <label for="testCase">Test Case:</label>
      <select id="testCase">
        <option value="tuina-hero">Tuina Hero Pattern (mask-image)</option>
        <option value="simple-mask">Simple Linear Mask</option>
        <option value="stroke-classes">Stroke with Tailwind Classes</option>
      </select>
    </div>

    <div class="section">
      <label>Original SVG (with CSS):</label>
      <textarea id="originalSVG" readonly></textarea>
    </div>

    <button id="cleanBtn">🔧 Clean SVG</button>

    <div class="section">
      <label>Cleaned SVG (native):</label>
      <textarea id="cleanedSVG" readonly></textarea>
    </div>

    <button id="importBtn" class="btn-success" disabled>
      📤 Import to Penpot
    </button>

    <div id="status" class="info">
      Select a test case and click Clean SVG to start.
    </div>

    <script>
      // Test cases with problematic CSS/HTML attributes
      const testCases = {
        "tuina-hero": `<svg class="absolute inset-0 -z-10 h-full w-full stroke-white/5 [mask-image:radial-gradient(75%_50%_at_top_center,white,transparent)]" aria-hidden="true">
  <defs>
    <pattern id="hero" width="80" height="80" x="50%" y="-1" patternUnits="userSpaceOnUse">
      <path d="M.5 200V.5H200" fill="none"></path>
    </pattern>
  </defs>
  <rect width="100%" height="100%" stroke-width="0" fill="url(#hero)"></rect>
</svg>`,

        "simple-mask": `<svg width="200" height="200" style="mask-image: linear-gradient(to bottom, black, transparent);">
  <rect x="10" y="10" width="180" height="180" fill="blue"/>
</svg>`,

        "stroke-classes": `<svg class="w-full h-full stroke-red-500/50" style="stroke-width: 2px;">
  <circle cx="100" cy="100" r="50" fill="none" class="stroke-current"/>
</svg>`,
      };

      const testCaseSelect = document.getElementById("testCase");
      const originalTextarea = document.getElementById("originalSVG");
      const cleanedTextarea = document.getElementById("cleanedSVG");
      const cleanBtn = document.getElementById("cleanBtn");
      const importBtn = document.getElementById("importBtn");
      const statusEl = document.getElementById("status");

      let currentCleaned = null;

      function setStatus(msg, type = "info") {
        statusEl.textContent = msg;
        statusEl.className = type;
      }

      // Load test case
      function loadTestCase() {
        const selected = testCaseSelect.value;
        originalTextarea.value = testCases[selected];
        cleanedTextarea.value = "";
        currentCleaned = null;
        importBtn.disabled = true;
        setStatus(
          'Click "Clean SVG" to convert CSS to native SVG attributes.',
          "info"
        );
      }

      // Clean SVG - convert CSS to native attributes
      function cleanSVG(svgString) {
        console.log("[Cleaner] Starting conversion...");
        console.log("[Cleaner] Input length:", svgString.length);

        const parser = new DOMParser();
        const doc = parser.parseFromString(svgString, "image/svg+xml");

        // Check for parsing errors
        const parseError = doc.querySelector("parsererror");
        if (parseError) {
          throw new Error("SVG parsing failed: " + parseError.textContent);
        }

        const svg = doc.documentElement;
        console.log("[Cleaner] SVG parsed successfully");

        // Extract mask-image from class attribute (Tailwind arbitrary values)
        function extractMaskFromClass(classStr) {
          if (!classStr) return null;
          const match = classStr.match(/\[mask-image:([^\]]+)\]/);
          return match ? match[1] : null;
        }

        // Convert CSS mask to SVG mask element
        function convertMaskToSVG(maskCSS, svgElement) {
          console.log("[Cleaner] Converting mask:", maskCSS);

          // Parse radial-gradient
          const radialMatch = maskCSS.match(/radial-gradient\(([^)]+)\)/);
          if (!radialMatch) {
            console.warn("[Cleaner] Not a radial gradient, skipping");
            return null;
          }

          const params = radialMatch[1];
          const parts = params.split(",").map((p) => p.trim());

          // Default values
          let cx = "50%",
            cy = "50%",
            r = "50%";
          let stops = [];

          // Parse: "75% 50% at top center, white, transparent"
          const firstPart = parts[0];
          if (firstPart.includes("at")) {
            const [size, pos] = firstPart.split("at").map((s) => s.trim());
            const sizeVals = size.split(/\s+/);
            r = sizeVals[0]; // Use horizontal size as radius

            // Parse position keywords
            if (pos.includes("top")) cy = "0%";
            if (pos.includes("bottom")) cy = "100%";
            if (pos.includes("center") && pos.includes("top")) cy = "0%";
            if (pos.includes("left")) cx = "0%";
            if (pos.includes("right")) cx = "100%";
            if (pos.split(/\s+/).includes("center")) cx = "50%";

            console.log("[Cleaner] Gradient position:", { cx, cy, r });
          }

          // Parse color stops
          for (let i = 1; i < parts.length; i++) {
            const color = parts[i];
            if (color.includes("transparent")) {
              stops.push({ offset: "100%", color: "white", opacity: "0" });
            } else if (color.includes("white")) {
              stops.push({ offset: "0%", color: "white", opacity: "1" });
            }
          }

          console.log("[Cleaner] Gradient stops:", stops);

          // Create or get defs
          let defs = svgElement.querySelector("defs");
          if (!defs) {
            defs = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "defs"
            );
            svgElement.insertBefore(defs, svgElement.firstChild);
          }

          // Create gradient
          const gradientId =
            "maskGradient-" + Math.random().toString(36).substr(2, 9);
          const gradient = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "radialGradient"
          );
          gradient.setAttribute("id", gradientId);
          gradient.setAttribute("cx", cx);
          gradient.setAttribute("cy", cy);
          gradient.setAttribute("r", r);

          stops.forEach((stop) => {
            const stopEl = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "stop"
            );
            stopEl.setAttribute("offset", stop.offset);
            stopEl.setAttribute("stop-color", stop.color);
            stopEl.setAttribute("stop-opacity", stop.opacity);
            gradient.appendChild(stopEl);
          });

          // Create mask
          const maskId =
            "maskElement-" + Math.random().toString(36).substr(2, 9);
          const mask = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "mask"
          );
          mask.setAttribute("id", maskId);

          const maskRect = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect"
          );
          maskRect.setAttribute("width", "100%");
          maskRect.setAttribute("height", "100%");
          maskRect.setAttribute("fill", `url(#${gradientId})`);
          mask.appendChild(maskRect);

          defs.appendChild(gradient);
          defs.appendChild(mask);

          console.log("[Cleaner] Created mask:", maskId);
          return maskId;
        }

        // Process SVG element
        const classAttr = svg.getAttribute("class");
        const styleAttr = svg.getAttribute("style");

        // Handle mask-image from class
        if (classAttr) {
          const maskCSS = extractMaskFromClass(classAttr);
          if (maskCSS) {
            console.log("[Cleaner] Found mask in class:", maskCSS);
            const maskId = convertMaskToSVG(maskCSS, svg);
            if (maskId) {
              // Apply mask to all direct children
              Array.from(svg.children).forEach((child) => {
                if (child.tagName !== "defs") {
                  child.setAttribute("mask", `url(#${maskId})`);
                  console.log("[Cleaner] Applied mask to:", child.tagName);
                }
              });
            }
          }

          // Parse stroke from Tailwind class (stroke-white/5 = white with 5% opacity)
          const strokeMatch = classAttr.match(/stroke-([a-z]+)\/(\d+)/);
          if (strokeMatch) {
            const color = strokeMatch[1];
            const opacity = parseInt(strokeMatch[2]) / 100;
            svg.setAttribute("stroke", color === "white" ? "#ffffff" : color);
            svg.setAttribute("stroke-opacity", opacity.toString());
            console.log("[Cleaner] Extracted stroke:", color, opacity);
          }
        }

        // Handle mask-image from style
        if (styleAttr && styleAttr.includes("mask-image")) {
          const maskMatch = styleAttr.match(/mask-image:\s*([^;]+)/);
          if (maskMatch) {
            const maskId = convertMaskToSVG(maskMatch[1], svg);
            if (maskId) {
              Array.from(svg.children).forEach((child) => {
                if (child.tagName !== "defs") {
                  child.setAttribute("mask", `url(#${maskId})`);
                }
              });
            }
          }
        }

        // Remove CSS classes and non-SVG attributes
        svg.removeAttribute("class");
        svg.removeAttribute("style");
        svg.removeAttribute("aria-hidden");

        // Process all children
        svg.querySelectorAll("*").forEach((el) => {
          el.removeAttribute("class");

          const elStyle = el.getAttribute("style");
          if (elStyle) {
            // Parse style into attributes
            const styles = elStyle.split(";").reduce((acc, s) => {
              const [prop, val] = s.split(":").map((x) => x.trim());
              if (prop && val) acc[prop] = val;
              return acc;
            }, {});

            if (styles.stroke) el.setAttribute("stroke", styles.stroke);
            if (styles["stroke-width"])
              el.setAttribute("stroke-width", styles["stroke-width"]);
            if (styles.fill) el.setAttribute("fill", styles.fill);
            if (styles.opacity) el.setAttribute("opacity", styles.opacity);

            el.removeAttribute("style");
          }
        });

        // Serialize back to string
        const serializer = new XMLSerializer();
        const result = serializer.serializeToString(svg);

        console.log(
          "[Cleaner] Conversion complete, output length:",
          result.length
        );
        return result;
      }

      // Event listeners
      testCaseSelect.addEventListener("change", loadTestCase);

      cleanBtn.addEventListener("click", () => {
        try {
          setStatus("🔄 Converting CSS to native SVG...", "info");
          const cleaned = cleanSVG(originalTextarea.value);
          cleanedTextarea.value = cleaned;
          currentCleaned = cleaned;
          importBtn.disabled = false;
          setStatus("✅ SVG cleaned successfully! Ready to import.", "ok");
        } catch (err) {
          console.error("[UI] Clean error:", err);
          setStatus(`❌ Clean failed: ${err.message}`, "err");
          currentCleaned = null;
          importBtn.disabled = true;
        }
      });

      importBtn.addEventListener("click", () => {
        if (!currentCleaned) {
          setStatus(
            '❌ No cleaned SVG to import. Click "Clean SVG" first.',
            "err"
          );
          return;
        }

        setStatus("📤 Importing to Penpot...", "info");

        parent.postMessage(
          {
            pluginMessage: {
              type: "import-svg",
              svgString: currentCleaned,
            },
          },
          "*"
        );
      });

      // Listen for plugin responses
      window.addEventListener("message", (event) => {
        const msg = event.data && event.data.pluginMessage;
        if (!msg) return;

        if (msg.type === "import-success") {
          setStatus("✅ " + msg.detail, "ok");
        } else if (msg.type === "import-error") {
          setStatus("❌ " + msg.detail, "err");
        }
      });

      // Initialize
      loadTestCase();
    </script>
  </body>
</html>
